import 'dart:async';
import 'dart:typed_data';
import 'dart:ui';

import 'package:flutter/rendering.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:flutter_map/src/layer/modern_tile_layer/tile_loader/raster/image_provider.dart';
import 'package:flutter_map/src/layer/modern_tile_layer/tile_loader/raster/internal_tile_data.dart';
import 'package:meta/meta.dart';

/// A tile loader implementation which:
///
///  1. delegates to a [SourceGenerator] to output the tile's 'source' ([S])
///  2. fetches the 'source's bytes by delegating to a [SourceBytesFetcher]
///  3. outputs an [InternalRasterTileData], containing the [ImageProvider]
///     created by decoding the tile's image bytes
///
/// The source ([S]) is used as the short-term caching key for the
/// [ImageProvider] (in Flutter's [ImageCache]) - therefore, it must meet the
/// necessary conditions as described by [ImageProvider.obtainKey]
/// (particularly, it must be an object with a useful equality defined). The
/// [TileSource] generated by the [XYZSourceGenerator] & [WMSSourceGenerator]
/// meets this requirement, although it is not a requirement to use this.
@immutable
class RasterTileLoader<S extends Object>
    implements TileLoader<InternalRasterTileData> {
  /// Generates a 'source' ([S]) for a tile, given its [TileCoordinates] & the
  /// ambient [TileLayerOptions]
  ///
  /// For example, see [XYZSourceGenerator].
  final SourceGenerator<S> sourceGenerator;

  /// The delegate which provides the bytes for the this tile, based on its
  /// 'source' ([S]).
  ///
  /// This may not be called for every tile, if the tile was already present in
  /// the ambient [ImageCache].
  ///
  /// For example, see [NetworkBytesFetcher].
  final SourceBytesFetcher<S> bytesFetcher;

  /// Tile loader which loads raster image tiles
  const RasterTileLoader({
    required this.sourceGenerator,
    required this.bytesFetcher,
  });

  @override
  InternalRasterTileData call(
    TileCoordinates coordinates,
    TileLayerOptions options,
  ) {
    final source = sourceGenerator(coordinates, options);

    final abortTrigger = Completer<void>();

    Future<Codec> imageDelegate(
      KeyedDelegatedImage key, {
      required StreamSink<ImageChunkEvent> chunkEvents,
      required ImageDecoderCallback decode,
    }) async {
      void evict() => scheduleMicrotask(
            () => PaintingBinding.instance.imageCache.evict(key),
          );

      Future<Codec> transformer(Uint8List bytes, {bool allowReuse = true}) {
        if (!allowReuse) evict();
        return ImmutableBuffer.fromUint8List(bytes).then(decode);
      }

      try {
        return await bytesFetcher(
          source: source,
          abortSignal: abortTrigger.future,
          transformer: transformer,
          bytesLoadedCallback: (c, t) => chunkEvents.add(
            ImageChunkEvent(cumulativeBytesLoaded: c, expectedTotalBytes: t),
          ),
        );
      } on TileAbortedException {
        evict();
        return ImmutableBuffer.fromUint8List(transparentImage).then(decode);
      } on Exception {
        evict();
        rethrow;
      }
    }

    return InternalRasterTileData.createAndLoad(
      image: KeyedDelegatedImage(
        key: source,
        delegate: imageDelegate,
      ),
      dispose: abortTrigger.complete,
    );
  }

  /// [Uint8List] that forms a fully transparent image.
  static final transparentImage = Uint8List.fromList([
    0x89,
    0x50,
    0x4E,
    0x47,
    0x0D,
    0x0A,
    0x1A,
    0x0A,
    0x00,
    0x00,
    0x00,
    0x0D,
    0x49,
    0x48,
    0x44,
    0x52,
    0x00,
    0x00,
    0x00,
    0x01,
    0x00,
    0x00,
    0x00,
    0x01,
    0x08,
    0x06,
    0x00,
    0x00,
    0x00,
    0x1F,
    0x15,
    0xC4,
    0x89,
    0x00,
    0x00,
    0x00,
    0x0A,
    0x49,
    0x44,
    0x41,
    0x54,
    0x78,
    0x9C,
    0x63,
    0x00,
    0x01,
    0x00,
    0x00,
    0x05,
    0x00,
    0x01,
    0x0D,
    0x0A,
    0x2D,
    0xB4,
    0x00,
    0x00,
    0x00,
    0x00,
    0x49,
    0x45,
    0x4E,
    0x44,
    0xAE,
    0x42,
    0x60,
    0x82,
  ]);
}
