import 'dart:async';

import 'package:flutter_map/src/layer/modern_tile_layer/base_tile_layer.dart';
import 'package:meta/meta.dart';

/// Data associated with a particular tile coordinate which 'loads'
/// asynchronously
///
/// These are generated by the [BaseTileLayer.tileLoader] and consumed by the
/// [BaseTileLayer.renderer].
///
/// Association with a tile coordinate is made in the tile layer.
///
/// It is up to the implementation as to what 'loads' means. However, the
/// [BaseTileLayer] will use [whenLoaded], [isLoaded], and [dispose] to manage
/// (such as pruning) the tile for the renderer.
abstract interface class BaseTileData {
  /// Completes when the underlying resource is 'loaded'
  Future<void> get whenLoaded;

  /// Whether the underlying resource is 'loaded'
  bool get isLoaded;

  /// Called when a tile is removed from the map of visible tiles
  ///
  /// This should usually be used to abort loading of the underlying resource
  /// if it has not yet loaded, or release the resources held by it if already
  /// loaded.
  ///
  /// This should not usually be called externally.
  @internal
  void dispose();
}

/// Wrapper for custom-shape data as a [BaseTileData]
///
/// The data carried is usually made available asynchronously, for example as
/// the result of an I/O operation or HTTP request. Alternatively, data may be
/// available synchronously if the data is loaded from prepared memory. This
/// container supports either form of data.
class WrapperTileData<D extends Object?> implements BaseTileData {
  D? _data;

  /// Data resource
  ///
  /// This may be `null` if [D] is nullable & the data is `null`. In this case,
  /// use [isLoaded] to determine whether this accurately reflects the `null`
  /// data. Otherwise, `null` means the data is not yet available.
  D? get data => _data;

  final _loadedTracker = Completer<D>.sync();

  /// Completes with loaded data when the data is loaded successfully
  ///
  /// This never completes if the data completes to an error.
  @override
  Future<D> get whenLoaded => _loadedTracker.future;

  /// Whether [data] represents the loaded data
  @override
  bool get isLoaded => _loadedTracker.isCompleted;

  @internal
  @override
  void dispose() => _dispose?.call();
  final void Function()? _dispose;

  /// Create a container with the specified data (or the data result of the
  /// specified future)
  WrapperTileData({
    required FutureOr<D> data,
    void Function()? dispose,
  }) : _dispose = dispose {
    if (data is Future<D>) {
      data.then((data) => _loadedTracker.complete(_data = data));
    } else {
      _loadedTracker.complete(_data = data);
    }
  }
}
